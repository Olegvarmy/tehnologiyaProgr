Министерство Образования и Науки Российской Федерации НОВОСИБИРСКИЙ ГОСУДАРСТВЕННЫЙ ТЕХНИЧЕСКИЙ УНИВЕРСИТЕТ
No ____
￼«Технология программирования»
Методические указания к лабораторным работам для студентов по направлению 230100
«Информатика и вычислительная техника» очной формы обучения
НОВОСИБИРСК 2015
УДК 004.45 (076.5)
Составитель: Д.О. Романников, канд. техн. наук, ст. преп.
Рецензент А.В. Гунько, канд. техн. наук, доц. каф. Автоматики
Работа подготовлена на кафедре автоматики
© Новосибирский государственный технический университет, 2015 г.
СОДЕРЖАНИЕ
Лабораторная работа No1.............................................................................................4 Лабораторная работа No2.............................................................................................9 Лабораторная работа No3...........................................................................................11 Лабораторная работа No4...........................................................................................14 Лабораторная работа No5...........................................................................................15 Лабораторная работа No6...........................................................................................19 Лабораторная работа No7...........................................................................................21 Варианты заданий ...................................................................................................... 28
ЛАБОРАТОРНАЯ РАБОТА No1
Цель работы: изучить основы работы с классами в С++, а именно: структуру классов, спецификаторы области видимости, реализацию методов, в том числе, конструкторов и деструкторов.
Общие сведения
C++ — компилируемый статически типизированный язык программирования общего назначения. Является вторым по распространению языком в мире после Java. C++ используется не только в персональных и серверных компьютерах, но и широко распространен для программирования микроконтроллеров и DSP процессоров.
Hello world на С++
Самой распространенной программой для начала изучения языка программирования является программа “Hello world”. Рассмотрим программу, приведенную ниже:
#include <iostream>
using namespace std;
void main() {
  cout << "Hello world!" << endl;
  cout << "Let’s start learn the C++ language" << endl;
  return 0;
}
Данная программа выводит на консоль строки «Hello world» и «Let’s start learn the C++ language». Реализуется при помощи выражения «cout <<», которое используется для вывода на поток stdout выражения стоящего правее. Для работы с «cout» необходимо подключить библиотеку <iostream> и указать, что будет использоваться пространство имен (namespace) std.
Классы
В С++ для программирования в объектно-ориентированном стиле используются классы и объекты. Пример объявления класса приведен ниже: #include <iostream>
using namespace std;
class Line {
private:
  double length;
public:
  void set_length(double);
  double get_length(void);
  line();
};
Необходимо отметить, что хорошей практикой является разделение объявления класса и его реализации по отдельным файлам. Например, вышеприведенный код необходимо разместить в файле с названием класса – «line» и расширением «h» или «hpp» (line.h/line.hpp). А реализацию методов класса разместить отдельно в файле «line.cpp». Рассмотрим эту реализацию:
#include “line.h”
using namespace std;
void Line::set_length( double len )
{
  length = len;
}
double Line::get_length( void )
{
  return length;
}
Методы класса имеют доступ к атрибутам класса: могут получать значение переменных и изменять его. Пример использования реализованного класса приведен ниже:
int main() {
  Line new_line;
  new_line.set_length(6.0);
  cout << "Length of line : " << new_line.get_length();
  cout << endl;
return 0; }
Классы в С++ могут иметь различную область видимости, а именно:
 private – атрибуты или методы доступны только «внутри» класса;
 protected – атрибуты или методы доступны «внутри» класса, а также
классам потомкам;
5
 public – атрибуты или методы доступны как «внутри» и «снаружи» класса, так и для потомков.
Работа с памятью в С++
С++ как язык, не содержащий «сборщика мусора», предполагает ручное управление памятью. Для выделения памяти используется оператор new, а для ее освобождения оператор delete.
Синтаксис выделения и освобождения памяти с использованием операторов new и delete приведен ниже:
Где p_var – это указатель типа typename. Рассмотрим пример использования операторов new/delete для классов:
#include <iostream>
#include “line.h”
using namespace std;
int main() {
  Line *new_line = new Line;
  new_line->set_length(6.0);
  cout << "Length of line : " << new_line->get_length();
  cout << endl;
  delete new_line;
return 0; }
Конструкторы, деструкторы
При программировании в ООП стиле часто бывает необходимым выполнить начальную инициализацию объекта, например: выделить память под атрибуты класса, создать файл или выполнить запрос в базу данных. Для этих целей используются конструкторы. Деструктор имеет обратное назначение. Данные методы подчиняются следующим правилам:
 Конструктор имеет такое же имя, как и класс;
 Конструктор не имеет возвращаемого значения;
￼p_var = new typename;
￼delete p_var
6
 Когда в программе создается экземпляр класса, компилятор вызывает конструктор, если конструктор существует, или конструктор по умолчанию, если конструктор не существует;
 Деструктор имеет такое же имя, как и класс, но содержит тильду «~» перед именем;
 Деструктор не имеет возвращаемого значения.
Рассмотрим пример реализации конструктора:
#include <iostream>
using namespace std;
class Line
{
private:
  double *length;
public:
Line(int);
~Line();
void set_length(double); double get_length(void); Line();
};
Line::Line(void)
{
  length = new double;
}
Line::~Line(void)
{
  delete length;
}
void Line::set_length( double len )
{
  *length = len;
}
double Line::get_length( void )
{
  return *length;
}
int main() {
  Line *new_line = new Line;
  new_line->set_length(6.0);
7
  cout << "Length of line : " << new_line->get_length();
  cout << endl;
  delete new_line;
return 0; }
Хорошей практикой программирования является покрытие кода unit- тестами – специальными тестами, которые позволяют проверить на корректность отдельные части кода (классы, методы). Задача любого теста сопоставить результат выполнения проверяемого кода с ожидаемым результатом. Например, проверяя если необходимо проверить функцию length класса std::string то один из вариантов проверки будет иметь следующий вид:
bool checkPositiveLength() {
  string s(“aaa”);
  return s.length() == 3;
}
bool checkEmptyString() {
  string s(“”);
  return s.length() == 0;
}
Порядок выполнения работы
1. Реализовать функции программы согласно варианту. Сделать атрибуты класса приватными. Добавить в класс методы для валидации входных данных в методах. Общий код вынести в отдельные методы;
2. Запретить всем методам (для которых это возможно по смыслу) менять состояние класса;
3. Написать unit-тесты.
Методические указания
1. Выполните декомпозицию поставленной задачи. Покажите взаимосвязи между классами;
2. Вызов утилиты должен иметь вид CLI («./<name> [--param_name] [param_value]», например («./lab1 --add_task task1»);
3. Для работы с входными параметрами argv реализуйте отдельный класс;
4. Задайте методам класса с минимально допустимые области видимости;
5. Отчет должен содержать примеры запуска программы и результаты
запуска unit-тестов.
8
Контрольные вопросы
1. Для чего нужны классы?
2. Какими способами выполняется обращение к методам/атрибутам
объекта?
3. Какие бывают спецификаторы областей видимости, чем они
отличаются?
4. Как в С++ выполняется вывод на stdout/stderr?
5. В каких случаях класс может содержать несколько конструкторов? Как
компилятор определяет какой конструктор необходимо вызвать?
6. При каких условиях вызывается деструктор класса? Примеры.
7. Когда нужно выделять память под переменные статически, когда
динамически?
ЛАБОРАТОРНАЯ РАБОТА No2
Цель работы: изучить основные принципы наследования классов в С++.
Общие сведения
Наследование – механизм, позволяющий написать новый класс (дочерний, производный) на основе уже существующего класса (родительского, базового). При этом поведение дочернего класса определяется методами и атрибутами, которые получены от класса-родителя, а также новыми методами и атрибутами дочернего класса.
Рассмотрим пример наследования классов.
class Parent {};
class Child_1: public Parent {};
class Child_2: protected Parent {};
class Child_3: private Parent {};
В данном примере от базового класса Parent наследуются классы Child_1,
Child_2, Child_3, причем все наследуемые классы имеют различные спецификаторы наследования: public, protected, private. Public-наследование означает, что те методы и атрибуты базового класса, которые были объявлены как public и protected остаются public и protected после наследования соответственно. Protected-наследование означает, что те методы и атрибуты базового класса, которые были объявлены как public и protected будут иметь спецификатор доступа protected после наследования. Private-наследование означает, что те методы и атрибуты базового класса,
9
которые были объявлены как public и protected будут иметь спецификатор доступа private после наследования.
Стоит заметить, что не все методы и атрибуты класса наследуются. Наследованию не подлежат все конструкторы, деструкторы класса, методы и атрибуты, которые имеют спецификатор private.
Конструкторы
Конструкторы при наследовании классов не наследуются. Также объявление конструктора в классе-потомке выглядит иначе. Рассмотрим пример.
class Parent
{
  int x, y;
public:
  Parent(int a, int b);
};
Parent::Parent(int x, int y) {
  this->x = x;
  this->y = y;
}
class Child: public Parent
{
  int z;
public:
  Child(int x, int y, int z);
};
Child::Child(int x, int y, int z): Parent(x, y)
{
this->z = z; }
Обратите внимание на то, каким образом объявлен конструктор для класса
Child: после обычного объявления конструктора следует вызов конструктора
родительского класса с аргументами из конструктора класса-наследника.
10
Порядок вызова конструкторов/деструкторов
При наследовании важное значение имеет то, в каком порядке будут вызываться конструкторы/деструкторы родительского и дочернего классов. Порядок вызова конструкторов/деструкторов следующий: при создании объекта дочернего класса конструкторы вызываются в порядке от родительского класса к классу-наследнику. Деструкторы вызываются строго в противоположном порядке – от дочернего класса к родительскому.
Переопределение методов
Цель наследования классов – изменить поведение класса потомка на основании поведения класса-родителя. Для этого можно добавлять новые методы (чаще всего с использованием методов родительского класса) или переопределить поведение существующих.
Порядок выполнения работы
1. В соответствии с заданием определить поведение каких классов необходимо изменить и реализовать наследование;
2. Написать unit-тесты для новой функциональности.
Методические указания
1. Добавить в программу новые сущности согласно варианту с использованием механизма наследования (где это необходимо);
2. Отчет должен содержать примеры запуска программы и результаты запуска unit-тестов.
Контрольные вопросы
1. Для чего нужно наследование?
2. Как работает наследование в С++? Какие области видимости
наследуются?
3. Почему в С++ принято определять виртуальный деструктор?
4. Наследуются ли конструкторы/деструкторы классов?
5.Каким образом можно из класса потомка обратиться к
методам/атрибутам родительского класса?
6. Как происходит вызов конструкторов в цепочке классов наследников?
ЛАБОРАТОРНАЯ РАБОТА No3
Цель работы: изучить основные принципы работы с контейнерами STL и их итераторами в С++.
11
Общие сведения
В стандартной библиотеке (STL) C++ для работы с распространенными структурами данных есть множество реализованных классов для упрощения работы с ними. Основными контейнерами являются: vector, map, set, list, bitset, queue, stack.
Для работы с массивами в С++ используется специальный контейнер vector. Создание вектора выполняется следующим образом: «vector<type> variable_name;», где type – любой валидный тип данных, а variable_name – имя контейнера. Основными методами для работы с векторами являются:
v.push_back(100); // Добавление нового значения (100) в конец массива v.pop_back(); // Извлечение из массива последнего значения
v.at(10) = 5; //v[10] = 5; Обращение к 10-ому элементу массива
size_t size = v.size(); // Получение размера массива
bool v.empty(); // Проверка на то, что массив пуст
v.clear(); // Удаляет все элементы массива
Контейнер list также предназначен для работы с массивами, но в отличие от вектора, в котором элементы массива хранятся в непрерывной последовательной области памяти, элементы массива хранятся в произвольных ячейках памяти, что приводит к более медленной сортировке и более быстрому добавлению/удалению в произвольном месте массива.
Создание списка выполняется так же, как и для вектора, за исключением использования ключевого слова list: «list<type> variable_name;».
Другим важным контейнером для ассоциации по типу ключ-значение, является контейнер map. Для создания контейнера необходимо подключить заголовочный файл <map> и написать «map <key type,data type> variable _name;», где key_type и data_type тип данных ключа и значения соответственно. Для доступа к контейнеру можно использовать запись: variable_name[key]. Основными методами для работы с контейнером являются:
bool m.empty(); // Проверка на то, что контейнер пуст
m.count(key); // Возвращает 1 если элемент с ключом key существует, иначе 0
m.find(key); // Возвращает итератор на элемент с указанным ключом
12
m.erase(it); // Удаляет элемент с заданным итератором
m.size(); // Получение размера
m.clear(); // Удаляет все элементы массива
Итератор (iterator) – специальный тип данных, предназначенный для универсального перебора элементов контейнеров.
Во всех контейнерах С++ есть методы begin() и end(), возвращающие итераторы для соответствующих контейнеров. Перебор элементов c использованием итераторов будет выглядеть следующим образом:
vector<int> myvector;
for (vector<int>::iterator it = myvector.begin(); it != myvector.end(); ++it)
  cout << *it << endl;
Порядок выполнения работы
1. Реализовать функции программы согласно варианту. Общий код необходимо вынести в отдельные методы;
2. Написать unit-тесты для новой функциональности.
Методические указания
1. Для реализации сортировки используйте подходящий контейнер. Объясните выбор контейнера;
2. При использовании С++11 удобно создавать итераторы при помощи ключевого слова auto: auto it = myvector.begin();
3. Отчет должен содержать примеры запуска программы и результаты запуска unit-тестов.
Контрольные вопросы
1. Какие есть контейнеры в С++?
2. За чем нужны контейнеры?
3. В чем отличие массивов от vector/list?
4. Что такое итераторы? Для чего они используются? 5. Как итерироваться по list, map, vector?
6. В чем отличие между stack/queue, list/vector?
13
ЛАБОРАТОРНАЯ РАБОТА No4
Цель работы: изучить способы переопределения операторов класса и их
использование.
Общие сведения
Язык С++ позволяет выполнить перегрузку операторов, что по сути является более удобным способов вызова методов классов. Перегрузка операторов должна использоваться для упрощения чтения и написание кода. Рассмотрим примеры перегрузки операторов.
Унарный оператор. По синтаксису перегрузка операторов напоминает перегрузку методов с использованием ключевого слова operator. Например:
class CodeBlock {
  int value;
public:
  CodeBlock& operator++() { // префиксный оператор
c.value++;
return c; }
  CodeBlock& operator++(int) { // постфиксный оператор
    CodeBlock before_add(this);
    this.value++;
    return before_add;
} };
В рассмотренном выше примере переопределяется унарный оператор «++». Стоит заметить, что в примере показано переопределение оператора в случае его префиксного использования (++с) и постфиксного использования (с++).
Рассмотрим пример переопределения бинарного оператора сравнения «==»: class CodeBlock {
int value;
14
public:
  bool operator==(CodeBlock& right) {
    return this.value == right.value;
  }
};
В отличие от предыдущего примера, при перегрузке бинарного оператора необходимо передать аргумент, стоящий справа в выражении.
Выполнять перегрузку операторов можно как внутри класса: как это показано на примерах выше, так и глобально. При это при перегрузке операторов глобально добавляется новый аргумент в сигнатуре функции:
CodeBlock& operator++(CodeBlock& c);
bool operator==(CodeBlock& left, CodeBlock& right);
Порядок выполнения работы
1. Необходимо реализовать функции поиска/фильтрации в программе согласно варианту;
2. Напишите unit-тесты для реализованных функций.
Методические указания
1. Для реализации функций поиска/фильтрации необходимо использовать переопределенные операторы;
2. Создайте не менее 3 различных фильтров по различным атрибутам;
3. Отчет должен содержать примеры запуска программы, а также
результаты запуска unit-тестов.
Контрольные вопросы
1. Для чего необходимо выполнять перегрузку операторов?
2. Какие операторы можно/нельзя переопределять?
3. Каким образом различается переопределение
префиксных/постфиксных операторов?
4. Как выполняются операции преобразования типов?
5. В чем разница переопределения операторов локально и глобально?
ЛАБОРАТОРНАЯ РАБОТА No5
Цель работы: изучить работу с потоками. 15
Общие сведения
В С++ используются потоки (stream, не путать с потоками операционной системы) для работы с операциями ввода/вывода на консоль или файлы. Концепция потоков широко используется в С++ из-за того, что она обладает следующими достоинствами:
 универсальность. Все классы потоков реализуют один интерфейс, поэтому разработчику нет необходимости заботиться о типе потока;
 масштабируемость. Разработчик может легко добавить методы работы
с потоками для своих объектов;
 абстракция. Разработчику нет необходимости указывать тип
вводимого/выводимого объектов.
Для работы с потоками в С++ используется иерархия классов (рис. 1).
￼￼ios_base ios
￼￼cin
cout, cerr, clog
￼￼￼￼￼￼￼￼ostream
￼￼￼￼￼￼￼￼￼￼fstream
iostream
fstream
istream
streambuf
￼filebuf
ifstream
￼￼￼￼￼￼￼stringstream
stringstream
stringbuf
istringstream
Рис. 1. Иерархия классов для работы с потоками в С++
Основными типами потоков являются: потоки для работы с вводом/выводом на консоль (<ostream>, <istream>, <iostream>) и глобальные объекты (cin, cout, cerr, clog), через которые происходит доступ к потокам, потоки для работы с вводом/выводом в файл (<filebuf>), потоки для форматирования строк (<stringsteam>, <istringsteam>, <ostringsteam>).
Для операции записи в поток используется оператор «<<»: cout << “My dummy string”;. Для операции чтения из потока используется оператор «>>»: cin >> “Input any value: ”;.
Для форматирования строк в С++ применяется класс stringstream. Пример применения рассмотрен ниже:
#include <sstream>
#include <iostream>
16
int main () {
  std::stringstream ss; int v = 44;
std::cout << “The value of v variable is: \”” << v << “\”” << std:endl;
ss << v;
  std::string s = ss.str();
}
Базовый класс ios предоставляет методы для определения состояния потока: bool good() – сигнализирует, что ни один из битов eofbit, failbit, badbit не взведен; bool eof() – сигнализирует о том, что «End-of-File» достигнут для последовательности данных ассоциированных с потоком; bool fail() – возвращает true, если один из failbit, badbit битов взведен; bool bad() – возвращает true, если взведен badbit бит, означающий потерю целостности потока. Также получить значение битов состояний можно при помощи метода iostate rdstate().
Для работы с файлами также используются потоки. Рассмотрим пример:
#include <iostream>
#include <fstream>
int main () {
  std::fstream fs;
  fs.open ("test.txt");
  if (fs.is_open()) {
    fs << "add string to file";
    std::cout << "Operation successfully performed\n";
    fs.close();
  } else {
    std::cout << "Error opening file";
}
return 0; }
17
В данном примере для открытия файла используется метод void open (const char* filename, ios_base::openmode mode = ios_base::in | ios_base::out). Для проверки открытия файла метод bool is_open() и для закрытия – метод void close().
Важной частью потоков в С++ является переопределение операций чтения/записи для объектов. Рассмотрим пример класса с переопределенными операторами.
#include <iostream>
using namespace std;
class Pair {
  int first, second;
public:
  Pair(int a, int b) {
    first = a; second = b;
  }
  friend ostream& operator<<(ostream &output, const Pair &p);
  friend istream& operator>>(istream &input, Pair &p);
};
ostream& operator<<(ostream &output, const Pair &p ) {
  output << "(" << p.first << ", " << p.second << ")" << endl;
  return output;
}
istream& operator>>( istream &input, Pair &p ) {
  input >> p.first >> p.second;
  return input;
}
int main() {
18
  Pair p(1, 3);
  cout << p;
  cin >> p;
  cout << p;
}
Порядок выполнения работы
1. Необходимо реализовать функции ввода/вывода сущностей из потока в программе согласно варианту;
2. Напишите unit-тесты для реализованных функций.
Методические указания
1. Для реализации ввода сущности в поток используйте последовательность символов с разделителями так, чтобы было возможно вводить несколько сущностей за «один такт»;
2. Для перенаправления потока ввода в запускаемую программу можно использовать следующую команду для Windows: program < “ sample_string;10;20@string_again;30;40” и для Linux: ./program < “sample_string;10;20@string_again;30;40” или для нескольких вводов подряд “echo -e "11\n22" | ./program”;
3. Отчет должен содержать примеры запуска программы, а также результаты запуска unit-тестов.
Контрольные вопросы
1. Как выполняется перегрузка операторов ввода/вывода?
2. Модификаторы открытия файла.
3. Как определить пригодность потока к работе/ошибки/другие
состояния?
4. Файловые потоки.
5. Как можно итерироваться по потоку?
ЛАБОРАТОРНАЯ РАБОТА No6
Цель работы: изучить работу с исключениями.
Общие сведения
Исключения – механизм языков программирования, предназначенный для описания реакции программы на различные ошибки и/или проблемы
19
(исключения). Также исключения позволяют значительно упросить затраты на обработку ошибок. Рассмотрим пример обработки исключений.
try { throw 1;
} catch (int a) {
  cout << "Exception handler: " << a << endl;
  return;
}
cout << "No exception detected!" << endl;
В вышеприведенном примере используются следующие ключевые слова: try, throw, catch. Конструкция throw используется для «кидания» исключения, где объектом исключения является аргумент. Конструкция catch (int a) {} является «ловушкой» для всех кидаемых исключений с типом int, которые «кидаются» в конструкции try {}. При перехвате исключения управление в программе передается в catch блок.
В стандартной библиотеке С++ используется иерархия классов исключений, где базовым классом является exception, которой содержит метод virtual const char* what() const noexcept для описания исключительных ситуаций.
Если в блоке try «кидается» несколько различных типов исключений, то можно использовать несколько catch конструкций, например:
try {
} catch (int a) {
  cout << "Exception handler: " << a << endl;
} catch (exception& e) {
  cout << "Exception handler: " << e.what() << endl;
} catch (...) {
  cout << "Catch all!" << endl;
}
20
В вышеприведенном примере catch(...) используется для перехвата всех исключений.
Порядок выполнения работы
1. Реализовать обработку ошибок в программе при помощи исключений.
Методические указания
1. В качестве объектов исключений используйте иерархию классов исключений;
2. Для различных по смыслу ошибок используйте различные классы исключений;
3. В базовом классе исключений реализуйте виртуальную функцию, в которой будет выводиться информация о классе объекта, файле и номера строки.
Для вывода номера строки и файла используйте встроенные макросы __LINE__ и __FILE__;
4. Отчет должен содержать примеры запуска программы и результаты запуска unit-тестов.
Контрольные вопросы
1. Для чего необходимы исключения в С++?
2. Каким образом перехватываются исключения в С++?
3. Иерархия стандартных исключений в STL.
4. Каким образом выполняется освобождение памяти при возникновении
исключительных ситуаций?
5. Зачем нужны именованные исключения?
ЛАБОРАТОРНАЯ РАБОТА No7
Цель работы: изучить принципы построения таких паттернов программирования как одиночка (singleton), декоратор, RAII, наблюдатель (observer), абстрактна фабрика.
Общие сведения
Паттерны программирования – повторимая архитектурная конструкция, представляющая собой решение некой проблемы проектирования в рамках некоторого часто возникающего контекста.
Паттерны делят на три категории:
21
 порождающие. Паттерны, которые абстрагируют для программиста способ создания объектов. Например, одиночка, абстрактная фабрика;
 поведенческие. Паттерны, определяют взаимодействие между объектами. Например, наблюдатель;
 структурные. Паттерны, которые изменяют интерфейс существующих объектов или их реализацию упрощая разработку или реализацию. Например, декоратор.
Цель шаблона одиночка заключается в гарантии того, что у класса будет только один экземпляр объекта и предоставлении доступа до этого объекта. Для этого запрещается создание объекта через конструкторы (в том числе и конструктор копирования), запрещается копирование объекта через присваивание, создается специальный метод, который будет «отдавать» объект. Пример реализации данного шаблона приведен ниже.
class CSingleton {
  CSingleton () {};
  CSingleton (CSingleton& root);
  CSingleton& operator=(CSingleton &); public:
  static CSingleton& get_instance()
{ static CSingleton instance; return instance; }
// поведение объекта
};
Целью шаблона декоратор является реализация схемы, при которой имеется
возможность подключать функциональность объекту динамически. Достигается это следующим способом: для объекта, поведение которого необходимо расширить, создается класс-наследник – декоратор; в класс- наследник (декоратор) добавляется указатель на расширяемый объект; в программе создается экземпляр базового класса; создается экземпляр класса декоратора, в конструктор которого передается «расширяемый» класс. Рассмотрим пример такого шаблона:
class library_item { int num_copies;
public:
  void set_num_copies(int value) { num_copies = value; }
  int get_num_copies(void) { return num_copies; }
  virtual void display(void) = 0;
};
class book : public library_item {
  book(); string author, title; public:
  book(string author, string title, int num_copies) :
    author(author), title(title) { set_num_copies(num_copies); }
  void display(void) {
    cout << "Book ------ " << endl
22
} };
<< "Author : " << author << endl
<< "Title : " << title << endl
<< "# Copies : " << get_num_copies() << endl;
class video : public library_item {
  video(); string director, title; public:
  video(string director, string title, int num_copies) :
    director(director), title(title) { set_num_copies(num_copies); }
  void display(void) {
    cout << "Video ------ "<< endl
         << "Director : "<< director << endl
         << "Title : "<< title << endl
         << "# Copies : " << get_num_copies() << endl;
} };
class decorator : public library_item {
  decorator();
protected:
  library_item* li; public:
  decorator (library_item* li) : li(li) {}
  void display(void) {
    li->display(); }
    int get_num_copies(void) { return li->get_num_copies();
  }
};
class decorator_borrow : public decorator {
  list <string> borrowers;
public:
  decorator_borrow(library_item* li) : decorator(li) {}
  void borrow(string name) { borrowers.push_back(name); }
  void display() {
    list <string>::iterator i;
    for(i = borrowers.begin(); i != borrowers.end(); ++i) {
      cout << *i << endl;
    }
} };
int main() {
  book *b1 = new book(“Autor1",“Book name1", 10);
  b1->display();
  video *v1 = new video("Autor2", "Book name2", 100);
  v1->display();
  decorator_borrow dec_b(v1);
23
  dec_b.borrow("Name 1");
  dec_b.borrow("Name 2");
  dec_b.display();
}
В примере используется две сущности, выраженные через классы book и video и имеющие общее поведение – метод display. Общий класс декораторов (decorator) и классы video, book имеют общего предка – класс library_item. Динамическое поведение реализуется с помощью класса decorator_borrow, в котором реализована функциональность займа сущности.
Основной идей принципа программирования RAII является ассоциация объекта класса с ресурсом для того, чтобы упростить логику работы с выделением и освобождением ресурса. А именно, при создании объекта класса ресурс выделяется: а при удалении объекта – освобождается. Примером применения паттерна RAII может быть работа с файлом:
class File {
  FILE* file_handler;
public:
  File(string filename) {
    file_handler = fopen(filename.c_str(), "w");
    if ( !file_handler )
      throw runtime_error(string("Can not open file:") + filename) ;
  }
  ~File() {
    if ( fclose(file_handler) != 0 )
      throw runtime_error("Can not close file.");
  }
  void write () {/* write code here */}
};
При создании объекта такого класса «захватывается» ресурс файла и удерживается на протяжении всего существования объекта в приватном атрибуте класса. Освобождение выполняется при уничтожении объекта. Паттерн наблюдатель реализует схему издатель-подписчик, т.е. реализует механизм оповещения всех подписанных классов на какое-то событие. Примером реализации паттерна является:
class Subject {
  vector < Observer* > views; int value;
public:
  void attach(Observer *obs) {
    views.push_back(obs); }
  void setVal(int val) { value = val; notify(); }
  int getVal() { return value; }
24
  void notify() {
  for (int i = 0; i < views.size(); i++)
    views[i]->update();
  }
};
class Observer {
  Subject *model; int denom;
public:
  Observer(Subject *mod, int div) {
    model = mod; denom = div; model->attach(this);
}
  virtual void update() = 0;
protected:
  Subject *getSubject() {return model;}
  int getDivisor() {return denom;}
};
class DivObserver: public Observer {
public:
  DivObserver(Subject *mod, int div): Observer(mod, div){}
  void update() {
    int v = getSubject()->getVal(), d = getDivisor();
    cout << v << " div " << d << " is " << v/d << '\n';
  }
};
class ModObserver: public Observer {
public:
  ModObserver(Subject *mod, int div): Observer(mod, div){}
  void update() {
    int v = getSubject()->getVal(), d = getDivisor();
    cout << v << " mod " << d << " is " << v%d << '\n';
  }
};
int main() {
  Subject subj;
  DivObserver divObs1(&subj, 4);
  DivObserver divObs2(&subj, 3);
  ModObserver modObs3(&subj, 3);
  subj.setVal(14);
}
Паттерн абстрактная фабрика необходим для абстрагирования от создания объектов классов: создание сущностей выполняется не при помощи оператора new, а с помощью специальных интерфейсов. Ниже приведен
пример, в котором создаются объекты различных классов локализации:
class Locale {
25
protected:
  string language;
public:
  string getLanguage() {return language;}
};
class RussianLocale : public Locale {
public:
  RussianLocale() {language = string("russian");};
};
class EnglishLocale : public Locale {
public:
  EnglishLocale() {language = string("english");};
};
class Factory {
public:
  static Locale* getLocale(bool isRussian = true) {
    static vector <Locale*> ll;
    if (isRussian) {
      ll.push_back(new RussianLocale());
    } else {
      ll.push_back(new EnglishLocale());
    }
    return ll.back();
  }
};
Порядок выполнения работы
1. Реализовать функции программы с использованием соответствующих паттернов согласно варианту;
2. Отчет долен содержать исходный код программы и примеры запуска программы иллюстрирующий используемый паттерн.
Варианты
1. Используя паттерн «одиночка», реализовать класс логгирования сообщений программы. В лог должно выводиться: тип записи (INFO, DEBUG, WARNING, ERROR), время записи, класс и строка, из которого вызван метод логгирования. Показать, что создается только один объект логгирования;
2. Создать класс «автомобиль». Используя паттерн «декоратор», динамически добавить/удалить дополнительную функциональность «покупки/продажи»;
26
3. Используя паттерн «RAII», реализовать свой класс, в котором реализуются функции (выделения ресурса, освобождение ресурса, доступ до ресурса) умного указателя «unique_ptr»;
4. Создать классы «кафе» и «посетитель». Используя паттерн «наблюдатель», реализовать подписку нескольких «посетителей» на события в «кафе». Показать, что все подписанные на события «посетители» получают сообщения;
5. Используя паттерн «абстрактная фабрика», реализовать создание классов согласно переданным в фабрику параметрам – название класса и версия;
6. Используя паттерн «одиночка», реализовать менеджер управления памятью. Менеджер должен иметь методы выделения заданного количество памяти под переменные, освобождения памяти под переменную. Показать, что создается только один объект менеджера;
7. Используя паттерн «декоратор», динамически добавить/удалить дополнительную функциональность «добавления/удаления пользователей» для сущности «сайт»;
8. Используя паттерн «RAII» реализовать свой класс, в котором реализуются функции (выделения ресурса, освобождение ресурса, доступ до ресурса) умного указателя «shared_ptr»;
9. Создать классы «читатель» и «издатель». Используя паттерн «наблюдатель», реализовать «группу подписчиков» на новости различных «издателей». Показать, что все подписчики в группе получают сообщения от «издателя».
Методические указания
1. Во втором и седьмом вариантах для реализаций сущностей можно использовать методы с выводом на консоль;
2. В четверном варианте создайте несколько «посетителей» и подпишите их на разные события и покажите, что обработчики вызываются только для подписанные события.
Контрольные вопросы
1. Для чего нужны паттерны программирования? 2. Что такое паттерн «одиночка»?
3. Что такое паттерн «RAII»?
4. Что такое паттерн «наблюдатель»?
5. Что такое паттерн «декоратор»?
6. Что такое паттерн «абстрактная фабрика»?
27
ВАРИАНТЫ ЗАДАНИЙ
Результатом выполнения лабораторных работ по курсу «Технология программирования» является программа, в которой реализованы функции согласно приведенным ниже вариантам. Каждая из лабораторных работ должна добавлять функциональность в программу из предыдущей лабораторной работы.
В.1.Разработка CLI-утилиты для управления задачами. В ходе лабораторных работ последовательно необходимо реализовать следующее:
ЛР.1. Управление списком задач: создание/удаление/редактирование; ЛР.2. Управление списком пользователей и дефектами: создание/удаление/редактирование, назначение пользователя на задачу, создание/удаление дефекта к задаче;
ЛР.3. Реализуйте сортировку задач/дефектов по различным параметрам;
ЛР.4. Создать фильтры по заданным параметрам для поиска дефектов и/или задач;
ЛР.5. Создание сущностей из потока и вывод их в поток;
ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.2. Разработка CLI-утилиты для различных типов вычислений. В ходе лабораторных работ последовательно необходимо реализовать следующее:
ЛР.1. Выполнение алгебраических операций сложения/вычитания/ умножения/деления и логических операций сложения и вычитания; ЛР.2. Выполнение матричные операции сложения/вычитания;
ЛР.3. Реализуйте историю выполненных вычислений и ее отображение;
ЛР.4. Реализуйте функцию запоминания результата и извлечение запомненного результата;
ЛР.5. Выполнение операций из потока и вывод результатов в поток; ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
28
В.3. *Разработка CLI-утилиты для выполнения файловых операций. В ходе лабораторных работ последовательно необходимо реализовать следующее:
ЛР.1. Выполнение создания/копирование/переименования/удаления файлов;
ЛР.2. Выполнение создания/копирование/переименования/удаления директорий;
ЛР.3. Реализуйте вывод на экран отсортированного списка файлов согласно их именам;
ЛР.4. Поиск по имени файла/директории по заданному пути;
ЛР.5. Создание сущностей из потока и вывод результатов в поток; ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.4. Разработка CLI-утилиты для работы с датами. В ходе лабораторных работ последовательно необходимо реализовать следующее:
ЛР.1. Реализовать подсчет количества дней/месяцев/лет между датами;
ЛР.2. Реализовать отображение календаря на дисплей с разбиением на месяцы;
ЛР.3. Реализуйте историю выполненных вычислений и ее отображение;
ЛР.4. Реализовать преобразование между датой в формате DD.MM.YYYY в UNIX timestamp и обратно;
ЛР.5. Выполнение операций из потока и вывод результатов в поток; ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.5.Разработка CLI-утилиты для поиска слов в файле. В ходе лабораторных работ последовательно необходимо реализовать следующее:
ЛР.1. Реализовать поиск заданного текстового фрагмента в заданном файле;
ЛР.2. Реализовать поиск заданного текстового фрагмента во всех файлах директории;
ЛР.3. Реализуйте вывод на экран всех слов в файле в порядке их наибольшего вхождения;
ЛР.4. Реализуйте поиск заданного текстового фрагмента в файле с конца файла;
29
ЛР.5. Реализовать чтение заданного текстового фрагмента и списка файлов/директории из потока и вывод найденных строк в поток;
ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.6. Разработка CLI-утилиты для работы с рациональными числами (m/n, где n, m Є Z). В ходе лабораторных работ последовательно необходимо реализовать следующее:
ЛР.1. Выполнение операций умножения/деления/ сложения/вычитания на целое число;
ЛР.2. Выполнение операций умножения/деления/ сложения/вычитания между рациональными числами;
ЛР.3. Реализуйте историю выполненных вычислений и ее отображение;
ЛР.4. Реализуйте сложение/вычитание векторов рациональных чисел; ЛР.5. Выполнение операций из потока и вывод результатов в поток; ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.7. Разработка CLI-утилиты для работы с комплексными числами.
ЛР.1. Выполнение операций умножения/деления/ сложения/вычитания на целое число;
ЛР.2. Выполнение операций умножения/деления/ сложения/вычитания между комплексными числами;
ЛР.3. Реализуйте историю выполненных вычислений и ее отображение;
ЛР.4. Реализуйте сложение/вычитание векторов комплексных чисел; ЛР.5. Выполнение операций из потока и вывод результатов в поток; ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.8. *Разработка CLI-утилиты для работы с бинарными деревьями. ЛР.1.Выполнение операций создания дерева из списка/ поиска элемента в дереве;
ЛР.2. Выполнение операций отображения дерева в консоли; ЛР.3.Реализуйте функцию поиска элемента в бинарном дереве, которая будет возвращать элемент, если он был найден, «-1» если элемент не найден, а также список элементов дерева в порядке их обхода при поиске;
30
ЛР.4. Реализуйте функцию удаления элемента дерева;
ЛР.5. Выполнение операции поиска из потока и вывод результатов в поток;
ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
В.9. *Разработка CLI-утилиты для работы с графами.
ЛР.1. Выполнение операций создания графа из матрицы смежности/ списка смежности;
ЛР.2. Выполнение операций отображения графа в консоли;
ЛР.3. Реализуйте функцию поиска элемента в графе, которая будет возвращать элемент, если он был найден, «-1» если элемент не найден или до него нет пути, а также список элементов графа в порядке их обхода при поиске;
ЛР.4. Реализуйте функцию удаления элемента графа;
ЛР.5. Выполнение операции поиска из потока и вывод результатов в поток;
ЛР.6. Реализовать иерархию классов исключений и выполнить рефакторинг для внедрения контроля ошибок с использованием исключений.
31
ТЕХНОЛОГИЯ ПРОГРАММИРОВАНИЯ
Методические указания к лабораторным работам
Редактор Технический редактор
Лицензия No 021040 от 22.02.96. Подписано в печать ___.___.___. Формат 60 х 84 1/16. Бумага оберточная. Тираж 50 экз. Уч.-изд.л. 2,0. Печ.л. 2. Изд. No ______. Заказ No ______ Цена договорная
Отпечатано в типографии
Новосибирского государственного технического университета
630092, г. Новосибирск, пр. К. Маркса, 20
￼￼32
